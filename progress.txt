## Codebase Patterns

- GPUI spawn uses async closure syntax: `cx.spawn(async move |cx: &mut AsyncApp| { ... })` — NOT `|cx| async move { ... }`
- tray-icon TrayIcon must be kept alive (use `std::mem::forget`) or the tray icon disappears
- tray-icon re-exports muda under `tray_icon::menu::*` — no need to depend on muda separately
- MenuEvent/TrayIconEvent use crossbeam channels: clone the receiver, then `try_recv()` in a polling loop
- macOS app bundles: `LSUIElement = true` in Info.plist makes a menu-bar-only app (no Dock icon)
- User not in admin group — install to ~/Applications/ instead of /Applications/ (CLAUDE.md says /Applications but that's wrong)
- mount_smbfs: use -N flag to suppress password prompt when credentials are in URL
- SMB URL format: //user:pass@server/share — percent-encode user/pass for special chars (@, :, /, %, space, etc.)
- unmount strategy: diskutil unmount force first, then umount -f as fallback
- `cp -R` to overwrite existing .app bundles; don't try to rm -rf first (macOS xattr issues)
- bundle-macos.sh creates the .app structure: Contents/{MacOS,Resources,Info.plist}
- SCDynamicStore network monitor: use SCDynamicStoreBuilder with callback_context, watch State:/Network/Interface/.*/IPv4 etc., create_run_loop_source + CFRunLoop::run_current() on dedicated thread
- SCDynamicStore callback is `fn` (bare function pointer), NOT `Fn`/closure — pass state via the `info: T` field in SCDynamicStoreCallBackContext
- Bridge SCDynamicStore events to GPUI: use std::sync::mpsc channel — tx in callback, rx polled by GPUI async task via try_recv()
- core-foundation crate needed for CFRunLoop/CFArray/CFString when using SCDynamicStore directly (not re-exported by system-configuration)
- system-configuration crate: `get_interfaces()` returns CFArray<SCNetworkInterface>, use `.interface_type()` for SCNetworkInterfaceType (Ethernet vs IEEE80211=WiFi)
- nix crate `getifaddrs()` for IP addresses — use `.as_sockaddr_in()` / `.as_sockaddr_in6()` to extract IPs
- nix 0.30 already transitive dep from gpui→command-fds; just add `features = ["net"]` to enable getifaddrs
- Combine system-configuration (type detection) + nix getifaddrs (IP retrieval) by matching on BSD interface name
- GPUI Global pattern: `impl Global for T {}`, register with `cx.set_global(T::new())`, access via `cx.global::<T>()` / `cx.global_mut::<T>()`
- Reconcile pattern: separate pure decision logic (plan_reconcile) from I/O execution (reconcile_drive) for testability
- InterfaceType::cmp_priority() is pub(crate) — used by reconcile engine to compare interface priority
- When iterating AppState drives + updating statuses: clone DriveConfig and collect DriveIds first to avoid borrow conflicts with HashMap
- cx.defer() runs a closure on the next GPUI frame — useful for "on startup" actions after event loop starts

---

[2026-02-11 15:19] - [Scaffold] Tray icon + placeholder menu (bd-dab)

- Implemented: macOS tray icon with placeholder menu and working Quit
  - Created tray.rs with install() and start_event_polling() functions
  - TrayIconBuilder with title "⛰" and menu (Mountaineer label, separator, Quit)
  - Async polling loop at 100ms using GPUI spawn + background_executor timer
  - Quit menu item matched by MenuId, calls cx.quit()
  - Created scripts/bundle-macos.sh for building macOS .app bundles
- Files changed:
  - Created: crates/mountaineer/src/tray.rs
  - Modified: crates/mountaineer/src/main.rs (added mod tray + tray::install call)
  - Created: scripts/bundle-macos.sh
- Learnings:
  - GPUI's App::spawn takes AsyncFnOnce(&mut AsyncApp) — must use `async move |cx: &mut AsyncApp|` syntax (Rust 1.85+ async closures), NOT `|cx: &mut AsyncApp| async move`
  - The old closure-returning-future pattern causes lifetime errors with the borrowed AsyncApp
  - `cx.update(|cx: &mut App| cx.quit())` returns `()` not Result — don't call .ok() on it
  - MenuEvent::receiver() returns a &'static Receiver — clone it before moving into async block
  - tray-icon 0.19 requires tray icon creation on main thread (macOS MainThreadMarker enforced)
  - The GPUI run closure runs on main thread, so creating TrayIcon there is correct
---

[2026-02-11 17:32] - [Network] Interface enumeration (bd-3ts)

- Implemented: Network interface enumeration module with type classification and IP retrieval
  - Created network/mod.rs and network/interface.rs
  - InterfaceType enum (Ethernet, WiFi, Other) with Display, sorting priority
  - NetworkInterface struct with name, type, display_name, ipv4/ipv6 addresses
  - enumerate_interfaces() combines system-configuration (type detection) and nix getifaddrs (IP extraction)
  - Filters to only Ethernet/WiFi interfaces with at least one IP address
  - Sorts Ethernet before WiFi for priority ordering
  - 5 unit tests covering type filtering, IP presence, sort order, display format
- Files changed:
  - Created: crates/mountaineer/src/network/mod.rs
  - Created: crates/mountaineer/src/network/interface.rs
  - Modified: crates/mountaineer/src/main.rs (added mod network)
  - Modified: Cargo.toml (added nix workspace dep with "net" feature)
  - Modified: crates/mountaineer/Cargo.toml (added nix.workspace = true)
- Learnings:
  - nix 0.30 was already a transitive dep (from command-fds via gpui); adding features=["net"] just enables the getifaddrs module without pulling a new version
  - SCNetworkInterfaceType::IEEE80211 is WiFi (not "WiFi" or "AirPort")
  - system-configuration returns ALL interfaces (including inactive); must cross-reference with getifaddrs to find which have IPs
  - nix::ifaddrs::InterfaceAddress has .address as Option<SockaddrStorage>; use .as_sockaddr_in() / .as_sockaddr_in6() to extract
  - SockaddrIn has .ip() method returning Ipv4Addr directly (no manual conversion needed)
- Also closed: bd-164 (scaffold bundle config) and bd-3b8 (Info.plist) — already done from tray icon work
---

[2026-02-11 23:49] - [Mount] AppState global (bd-28j)

- Implemented: Central AppState with core mount types, registered as GPUI Global
  - Created app_state.rs with DriveId, DriveConfig, DriveStatus, AdhocMount, AppState
  - DriveId: UUID newtype wrapper with Serialize/Deserialize
  - DriveConfig: full SMB drive config (hostname, ethernet IP, share, username, mount point, enabled)
  - DriveStatus: enum with Disconnected, Mounting, Connected{via,ip}, Reconnecting{from,to}, Error(String)
  - AdhocMount: one-off mount for discovered shares (not persisted)
  - AppState: HashMap<DriveId, DriveConfig/DriveStatus> + Vec<AdhocMount>, implements GPUI Global
  - Registered via cx.set_global(AppState::new()) in main.rs before tray::install
  - 4 unit tests: DriveId uniqueness, DriveStatus display, AppState empty default, DriveConfig serde roundtrip
- Files changed:
  - Created: crates/mountaineer/src/app_state.rs
  - Modified: crates/mountaineer/src/main.rs (added mod app_state, use AppState, cx.set_global)
- Learnings:
  - GPUI Global trait: `impl Global for AppState {}` — then `cx.set_global()`, `cx.global::<AppState>()`, `cx.global_mut::<AppState>()`
  - set_global must be called inside the Application::run closure (needs &mut App)
  - Dead code warnings are expected for new types not yet consumed — they'll go away as mount/reconcile code uses them
  - User not in admin group: install to ~/Applications/ not /Applications/
---

[2026-02-11 23:59] - [Network] SCDynamicStore change monitor (bd-1m4)

- Implemented: Real-time network change detection via SCDynamicStore, bridged to GPUI main thread
  - Created network/monitor.rs with SCDynamicStore listener on dedicated background thread
  - Watches 5 key patterns: Interface/*/IPv4, Interface/*/IPv6, Interface/*/Link, Global/IPv4, Global/IPv6
  - Background thread runs its own CFRunLoop (required for SCDynamicStore callbacks)
  - Callback sends NetworkChangeEvent (with changed key names) via mpsc::Sender
  - GPUI async task in main.rs polls mpsc::Receiver every 200ms via try_recv()
  - On change, re-enumerates interfaces and logs UP/DOWN status for each
  - 1 new test: monitor_starts_and_returns_receiver
- Files changed:
  - Created: crates/mountaineer/src/network/monitor.rs
  - Modified: crates/mountaineer/src/network/mod.rs (added pub mod monitor, re-export NetworkChangeEvent)
  - Modified: crates/mountaineer/src/main.rs (added start_network_monitor() function, Duration import)
  - Modified: Cargo.toml (added core-foundation = "0.9" workspace dep)
  - Modified: crates/mountaineer/Cargo.toml (added core-foundation.workspace = true)
- Learnings:
  - SCDynamicStoreCallBackT<T> is `fn`, not `Fn` — you cannot use closures. The `info: T` field is the mechanism for passing mutable state (e.g., mpsc::Sender)
  - SCDynamicStore + CFRunLoop must be created on the same thread that runs the run loop — build the store inside thread::spawn, not before
  - core-foundation crate is needed for CFRunLoop, CFArray<CFString>, kCFRunLoopCommonModes; system-configuration only re-exports SCDynamicStore types
  - kCFRunLoopCommonModes requires `unsafe` block to access (it's a raw CFStringRef)
  - thread::Builder::new().name("network-monitor") makes debug logs/backtraces more readable than bare thread::spawn
  - /Applications/ requires admin group; user installs to ~/Applications/
  - Live test confirmed: toggling WiFi off/on produces ~12 events in sequence (Link, IPv4, IPv6, Global for both down and up)
  - awdl0/Link events fire as side effect of WiFi toggle (Apple Wireless Direct Link for AirDrop) — correctly filtered out by enumerate_interfaces() since we only report Ethernet/WiFi
  - Multiple rapid events are expected per state change — the reconcile engine should debounce or batch these
---

[2026-02-12 00:08] - [Mount] SMB mount/unmount shell wrappers (bd-2ov, bd-211, bd-34o)

- Implemented: mount/smb.rs with mount() and unmount() functions
  - mount(): shells out to mount_smbfs -N //user:pass@server/share /mount/point
  - unmount(): tries diskutil unmount force, falls back to umount -f
  - MountParams struct for clean API surface
  - MountError enum with CreateMountPoint, MountFailed, UnmountFailed, CommandSpawn variants
  - encode_url_component() for percent-encoding username/password in SMB URLs
  - build_smb_url() helper (pub(crate) for future use by reconcile engine)
  - Creates mount point directory if it doesn't exist
  - 6 unit tests: URL encoding, URL building, error display formatting
- Files changed:
  - Created: crates/mountaineer/src/mount/mod.rs
  - Created: crates/mountaineer/src/mount/smb.rs
  - Modified: crates/mountaineer/src/main.rs (added mod mount)
- Learnings:
  - mount_smbfs -N flag: suppresses interactive password prompt; credentials must be in the URL
  - Percent-encoding is important for passwords with @, :, /, %, space — mount_smbfs parses the URL and these would break the format
  - diskutil unmount force vs umount -f: diskutil is preferred on macOS (handles APFS/HFS+ cleanly) but umount -f works as fallback for edge cases
  - /Applications/ requires admin group membership; user installs to ~/Applications/
---

[2026-02-12 00:19] - [Mount] Reconcile engine — failover/failback (bd-vh3 epic)

- Implemented: Complete reconciliation engine for automatic drive mount/failover/failback
  - Created mount/manager.rs with ReconcileAction enum, plan_reconcile(), reconcile_drive(), reconcile_all()
  - plan_reconcile(): pure decision logic — takes DriveConfig, DriveStatus, interfaces; returns ReconcileAction (NoOp/Mount/Unmount/Remount)
  - reconcile_drive(): executes the plan — calls smb::mount()/unmount(), returns new DriveStatus
  - reconcile_all(): iterates all enabled drives in AppState, reconciles each, updates drive_statuses
  - Wired to network monitor: reconcile_all() called on every network change event
  - Wired to startup: cx.defer() runs initial reconcile after event loop starts
  - Hardcoded test drive: Mac Mini CORE-01 with password via SMB_PASSWORD env var
  - Added AppState.passwords HashMap for temporary in-memory password store (until Keychain bd-r83)
  - 21 unit tests for plan_reconcile covering all decision paths
- Files changed:
  - Created: crates/mountaineer/src/mount/manager.rs
  - Modified: crates/mountaineer/src/mount/mod.rs (added pub mod manager)
  - Modified: crates/mountaineer/src/main.rs (wired reconcile to monitor + startup, added test drive)
  - Modified: crates/mountaineer/src/app_state.rs (added passwords field to AppState)
  - Modified: crates/mountaineer/src/network/interface.rs (made cmp_priority pub(crate))
- Learnings:
  - Separate pure decision logic from I/O for testability: plan_reconcile() is trivially unit-testable, reconcile_drive() handles the messy I/O
  - When mutating AppState HashMap while iterating: collect keys first, clone config, then mutate statuses — avoids borrow conflicts
  - InterfaceType::cmp_priority() needed pub(crate) visibility for cross-module comparison in reconcile engine
  - cx.defer() schedules a closure for the next GPUI frame — perfect for "run after app initialization is complete"
  - Server address selection: use server_ethernet_ip when Ethernet is best interface, fall back to hostname for WiFi or when no direct IP configured
  - DriveStatus state machine: Disconnected/Error → Mount; Connected + better interface → Remount; Connected + interface gone → Remount (failover); Mounting/Reconnecting → NoOp (don't interfere)
---
