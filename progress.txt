## Codebase Patterns

- GPUI spawn uses async closure syntax: `cx.spawn(async move |cx: &mut AsyncApp| { ... })` — NOT `|cx| async move { ... }`
- tray-icon TrayIcon must be kept alive (use `std::mem::forget`) or the tray icon disappears
- tray-icon re-exports muda under `tray_icon::menu::*` — no need to depend on muda separately
- MenuEvent/TrayIconEvent use crossbeam channels: clone the receiver, then `try_recv()` in a polling loop
- macOS app bundles: `LSUIElement = true` in Info.plist makes a menu-bar-only app (no Dock icon)
- User not in admin group — install to ~/Applications/ instead of /Applications/
- `cp -R` to overwrite existing .app bundles; don't try to rm -rf first (macOS xattr issues)
- bundle-macos.sh creates the .app structure: Contents/{MacOS,Resources,Info.plist}
- SCDynamicStore network monitor: use SCDynamicStoreBuilder with callback_context, watch State:/Network/Interface/.*/IPv4 etc., create_run_loop_source + CFRunLoop::run_current() on dedicated thread
- SCDynamicStore callback is `fn` (bare function pointer), NOT `Fn`/closure — pass state via the `info: T` field in SCDynamicStoreCallBackContext
- Bridge SCDynamicStore events to GPUI: use std::sync::mpsc channel — tx in callback, rx polled by GPUI async task via try_recv()
- core-foundation crate needed for CFRunLoop/CFArray/CFString when using SCDynamicStore directly (not re-exported by system-configuration)
- system-configuration crate: `get_interfaces()` returns CFArray<SCNetworkInterface>, use `.interface_type()` for SCNetworkInterfaceType (Ethernet vs IEEE80211=WiFi)
- nix crate `getifaddrs()` for IP addresses — use `.as_sockaddr_in()` / `.as_sockaddr_in6()` to extract IPs
- nix 0.30 already transitive dep from gpui→command-fds; just add `features = ["net"]` to enable getifaddrs
- Combine system-configuration (type detection) + nix getifaddrs (IP retrieval) by matching on BSD interface name
- GPUI Global pattern: `impl Global for T {}`, register with `cx.set_global(T::new())`, access via `cx.global::<T>()` / `cx.global_mut::<T>()`

---

[2026-02-11 15:19] - [Scaffold] Tray icon + placeholder menu (bd-dab)

- Implemented: macOS tray icon with placeholder menu and working Quit
  - Created tray.rs with install() and start_event_polling() functions
  - TrayIconBuilder with title "⛰" and menu (Mountaineer label, separator, Quit)
  - Async polling loop at 100ms using GPUI spawn + background_executor timer
  - Quit menu item matched by MenuId, calls cx.quit()
  - Created scripts/bundle-macos.sh for building macOS .app bundles
- Files changed:
  - Created: crates/mountaineer/src/tray.rs
  - Modified: crates/mountaineer/src/main.rs (added mod tray + tray::install call)
  - Created: scripts/bundle-macos.sh
- Learnings:
  - GPUI's App::spawn takes AsyncFnOnce(&mut AsyncApp) — must use `async move |cx: &mut AsyncApp|` syntax (Rust 1.85+ async closures), NOT `|cx: &mut AsyncApp| async move`
  - The old closure-returning-future pattern causes lifetime errors with the borrowed AsyncApp
  - `cx.update(|cx: &mut App| cx.quit())` returns `()` not Result — don't call .ok() on it
  - MenuEvent::receiver() returns a &'static Receiver — clone it before moving into async block
  - tray-icon 0.19 requires tray icon creation on main thread (macOS MainThreadMarker enforced)
  - The GPUI run closure runs on main thread, so creating TrayIcon there is correct
---

[2026-02-11 17:32] - [Network] Interface enumeration (bd-3ts)

- Implemented: Network interface enumeration module with type classification and IP retrieval
  - Created network/mod.rs and network/interface.rs
  - InterfaceType enum (Ethernet, WiFi, Other) with Display, sorting priority
  - NetworkInterface struct with name, type, display_name, ipv4/ipv6 addresses
  - enumerate_interfaces() combines system-configuration (type detection) and nix getifaddrs (IP extraction)
  - Filters to only Ethernet/WiFi interfaces with at least one IP address
  - Sorts Ethernet before WiFi for priority ordering
  - 5 unit tests covering type filtering, IP presence, sort order, display format
- Files changed:
  - Created: crates/mountaineer/src/network/mod.rs
  - Created: crates/mountaineer/src/network/interface.rs
  - Modified: crates/mountaineer/src/main.rs (added mod network)
  - Modified: Cargo.toml (added nix workspace dep with "net" feature)
  - Modified: crates/mountaineer/Cargo.toml (added nix.workspace = true)
- Learnings:
  - nix 0.30 was already a transitive dep (from command-fds via gpui); adding features=["net"] just enables the getifaddrs module without pulling a new version
  - SCNetworkInterfaceType::IEEE80211 is WiFi (not "WiFi" or "AirPort")
  - system-configuration returns ALL interfaces (including inactive); must cross-reference with getifaddrs to find which have IPs
  - nix::ifaddrs::InterfaceAddress has .address as Option<SockaddrStorage>; use .as_sockaddr_in() / .as_sockaddr_in6() to extract
  - SockaddrIn has .ip() method returning Ipv4Addr directly (no manual conversion needed)
- Also closed: bd-164 (scaffold bundle config) and bd-3b8 (Info.plist) — already done from tray icon work
---

[2026-02-11 23:49] - [Mount] AppState global (bd-28j)

- Implemented: Central AppState with core mount types, registered as GPUI Global
  - Created app_state.rs with DriveId, DriveConfig, DriveStatus, AdhocMount, AppState
  - DriveId: UUID newtype wrapper with Serialize/Deserialize
  - DriveConfig: full SMB drive config (hostname, ethernet IP, share, username, mount point, enabled)
  - DriveStatus: enum with Disconnected, Mounting, Connected{via,ip}, Reconnecting{from,to}, Error(String)
  - AdhocMount: one-off mount for discovered shares (not persisted)
  - AppState: HashMap<DriveId, DriveConfig/DriveStatus> + Vec<AdhocMount>, implements GPUI Global
  - Registered via cx.set_global(AppState::new()) in main.rs before tray::install
  - 4 unit tests: DriveId uniqueness, DriveStatus display, AppState empty default, DriveConfig serde roundtrip
- Files changed:
  - Created: crates/mountaineer/src/app_state.rs
  - Modified: crates/mountaineer/src/main.rs (added mod app_state, use AppState, cx.set_global)
- Learnings:
  - GPUI Global trait: `impl Global for AppState {}` — then `cx.set_global()`, `cx.global::<AppState>()`, `cx.global_mut::<AppState>()`
  - set_global must be called inside the Application::run closure (needs &mut App)
  - Dead code warnings are expected for new types not yet consumed — they'll go away as mount/reconcile code uses them
  - User not in admin group: install to ~/Applications/ not /Applications/
---

[2026-02-11 23:59] - [Network] SCDynamicStore change monitor (bd-1m4)

- Implemented: Real-time network change detection via SCDynamicStore, bridged to GPUI main thread
  - Created network/monitor.rs with SCDynamicStore listener on dedicated background thread
  - Watches 5 key patterns: Interface/*/IPv4, Interface/*/IPv6, Interface/*/Link, Global/IPv4, Global/IPv6
  - Background thread runs its own CFRunLoop (required for SCDynamicStore callbacks)
  - Callback sends NetworkChangeEvent (with changed key names) via mpsc::Sender
  - GPUI async task in main.rs polls mpsc::Receiver every 200ms via try_recv()
  - On change, re-enumerates interfaces and logs UP/DOWN status for each
  - 1 new test: monitor_starts_and_returns_receiver
- Files changed:
  - Created: crates/mountaineer/src/network/monitor.rs
  - Modified: crates/mountaineer/src/network/mod.rs (added pub mod monitor, re-export NetworkChangeEvent)
  - Modified: crates/mountaineer/src/main.rs (added start_network_monitor() function, Duration import)
  - Modified: Cargo.toml (added core-foundation = "0.9" workspace dep)
  - Modified: crates/mountaineer/Cargo.toml (added core-foundation.workspace = true)
- Learnings:
  - SCDynamicStoreCallBackT<T> is `fn`, not `Fn` — you cannot use closures. The `info: T` field is the mechanism for passing mutable state (e.g., mpsc::Sender)
  - SCDynamicStore + CFRunLoop must be created on the same thread that runs the run loop — build the store inside thread::spawn, not before
  - core-foundation crate is needed for CFRunLoop, CFArray<CFString>, kCFRunLoopCommonModes; system-configuration only re-exports SCDynamicStore types
  - kCFRunLoopCommonModes requires `unsafe` block to access (it's a raw CFStringRef)
  - thread::Builder::new().name("network-monitor") makes debug logs/backtraces more readable than bare thread::spawn
  - /Applications/ requires admin group; user installs to ~/Applications/
---
